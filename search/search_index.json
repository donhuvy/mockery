{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mockery","text":"<p>Mockery is a project that aims to make the generation of mock implementations of Golang interfaces. The mocks generated in this project are based off of the <code>github.com/stretchr/testify</code> suite of packages.</p> <p></p>"},{"location":"#why-mockery","title":"Why mockery?","text":"<p>As described in the documentation for <code>github.com/stretchr/testify/mock</code>, fake implementations of your Golang interfaces can be manually curated. These hand-rolled mocks can utilize the <code>mock</code> package to direct your mock how it should behave once called, register calls with the package, and assert the way in which the mocks were called. Details of how those mocks are implemented will not be repeated here as it's well-documented on <code>testify</code>'s page.</p> <p>Instead, we provide an automatic way of generating structs that satisfy your interfaces, and interface with <code>github.com/stretchr/testify/mock</code> automatically. The methods provided by <code>mock</code> are accessible, but we also provide a number of conveniences. Take for example this interface:</p> string.go<pre><code>package example_project\ntype Stringer interface {\nString() string\n}\n</code></pre> <p>From this interface, we can generate a mock implementation using Golang reflection and syntax parsing. See this abbreviated snippet that was generated by mockery:</p> mock_string.go<pre><code>// MockStringer is an autogenerated mock type for the Stringer type\ntype MockStringer struct {\nmock.Mock\n}\ntype MockStringer_Expecter struct {\nmock *mock.Mock\n}\n// String provides a mock function with given fields:\nfunc (_m *MockStringer) String() string {\nret := _m.Called()\nvar r0 string\nif rf, ok := ret.Get(0).(func() string); ok {\nr0 = rf()\n} else {\nr0 = ret.Get(0).(string)\n}\nreturn r0\n}\ntype mockConstructorTestingTNewMockStringer interface {\nmock.TestingT\nCleanup(func())\n}\n// NewMockStringer creates a new instance of MockStringer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\nfunc NewMockStringer(t mockConstructorTestingTNewMockStringer) *MockStringer {\nmock := &amp;MockStringer{}\nmock.Mock.Test(t)\nt.Cleanup(func() { mock.AssertExpectations(t) })\nreturn mock\n}\n</code></pre> <p>Get Started</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This changelog describes major feature additions. Please view the <code>releases</code> page for more details on commits and minor changes.</p>"},{"location":"changelog/#mockery","title":"mockery","text":""},{"location":"changelog/#v2200-improved-return-value-functions","title":"<code>v2.20.0</code>: Improved Return Value Functions","text":"<p>Return value functions that return an entire method's return value signature can now be provided.</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\nfunc(ctx context.Context, s string) (string, error) {\nreturn s, nil\n}\n)\n</code></pre> <p>You may still use the old way where one function is provided for each return value:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\nfunc(ctx context.Context, s string) string {\nreturn s\n},\nfunc(ctx context.Context, s string) error {\nreturn nil\n},\n)\n</code></pre>"},{"location":"changelog/#2190-inpackage-suffix-option","title":"<code>2.19.0</code>: <code>inpackage-suffix</code> option","text":"<p>When <code>inpackage-suffix</code> is set to <code>True</code>, mock files are suffixed with <code>_mock</code> instead of being prefixed with <code>mock_</code> for InPackage mocks</p>"},{"location":"changelog/#v2160-config-search-path","title":"<code>v2.16.0</code>: Config Search Path","text":"<p>Mockery will iteratively search every directory from the current working directory up to the root path for a <code>.mockery.yaml</code> file, if one is not explicitly provided.</p>"},{"location":"changelog/#v2130-generics-support","title":"<code>v2.13.0</code>: Generics support","text":"<p>Mocks are now capable of supporting Golang generics.</p>"},{"location":"changelog/#v2110-mock-constructors","title":"<code>v2.11.0</code>: Mock constructors","text":"<p>Mockery v2.11 introduces constructors for all mocks. This makes instantiation and mock registration a bit easier and less error-prone (you won't have to worry about forgetting the <code>AssertExpectations</code> method call anymore).</p> <p>Before v2.11: Go<pre><code>factory := &amp;mocks.Factory{}\nfactory.Test(t) // so that mock does not panic when a method is unexpected\ndefer factory.AssertExpectations(t)\n</code></pre></p> <p>After v2.11: Go<pre><code>factory := mocks.NewFactory(t)\n</code></pre></p> <p>The constructor sets up common functionalities automatically - The <code>AssertExpectations</code> method is registered to be called at the end of the tests via <code>t.Cleanup()</code> method. - The testing.TB interface is registered on the <code>mock.Mock</code> so that tests don't panic when a call on the mock is unexpected.</p>"},{"location":"changelog/#v2100-expecter-structs","title":"<code>v2.10.0</code>: Expecter Structs","text":"<p>Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the <code>with-expecter: True</code> mockery configuration, you can enter into the expecter interface by simply calling <code>.EXPECT()</code> on your mock object.</p> <p>For example, given an interface such as Go<pre><code>type Requester interface {\nGet(path string) (string, error)\n}\n</code></pre></p> <p>You can use the type-safe expecter interface as such: Go<pre><code>requesterMock := mocks.NewRequester(t)\nrequesterMock.EXPECT().Get(\"some path\").Return(\"result\", nil)\nrequesterMock.EXPECT().\nGet(mock.Anything).\nRun(func(path string) { fmt.Println(path, \"was called\") }).\n// Can still use return functions by getting the embedded mock.Call\nCall.Return(func(path string) string { return \"result for \" + path }, nil)\n</code></pre></p>"},{"location":"changelog/#v200-major-update","title":"<code>v2.0.0</code>: Major Update","text":"<p>This is the first major update of mockery. Version 2 brings a handful of improvements to mockery:</p> <ul> <li>Structured and pretty console logging</li> <li>CLI now switches over to sp13/cobra</li> <li>Use of viper configuration parsing. You can now use a .mockery.yaml config file in your repository</li> <li>Various CI fixes and improvements</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>mockery uses spf13/viper under the hood for its configuration parsing. It is bound to three different configuration sources, in order of decreasing precedence:</p> <ol> <li>Command line</li> <li>Environment variables</li> <li>Configuration file</li> </ol> <p>If a parameter is named <code>with-expecter</code> and we want a value of <code>True</code>, then these are the formats for each source:</p> source value command line <code>--with-expecter=true</code> Environment variable <code>MOCKERY_WITH_EXPECTER=True</code> yaml <code>with-expecter: True</code>"},{"location":"configuration/#recommended-basic-config","title":"Recommended Basic Config","text":"<p>Copy the recommended basic configuration to a file called <code>.mockery.yaml</code> at the top-level of your repo:</p> .mockery.yaml<pre><code>inpackage: True\ntestonly: True\nwith-expecter: True\nkeeptree: False\n</code></pre> <p>mockery will search upwards from your current-working-directory up to the root path, so the same configuration should be able to follow you within your project.</p>"},{"location":"configuration/#parameter-descriptions","title":"Parameter Descriptions","text":"name description <code>name</code> The <code>name</code> option takes either the name or matching regular expression of the interface to generate mock(s) for. <code>all</code> It's common for a big package to have a lot of interfaces, so mockery provides <code>all</code>. This option will tell mockery to scan all files under the directory named by <code>--dir</code> (\".\" by default) and generates mocks for any interfaces it finds. This option implies <code>recursive: True</code>. <code>recursive</code> Use the <code>recursive</code> option to search subdirectories for the interface(s). This option is only compatible with <code>name</code>. The <code>all</code> option implies <code>recursive: True</code>. <code>output</code> mockery always generates files with the package <code>mocks</code> to keep things clean and simple. You can control which mocks directory is used by using <code>output</code>, which defaults to <code>./mocks</code>. <code>outpkg</code> Use <code>outpkg</code> to specify the package name of the generated mocks. <code>inpackage</code> and <code>keeptree</code> For some complex repositories, there could be multiple interfaces with the same name but in different packages. In that case, <code>inpackage</code> allows generating the mocked interfaces directly in the package that it mocks. In the case you don't want to generate the mocks into the package but want to keep a similar structure, use the option <code>keeptree</code>. <code>filename</code> Use the <code>filename</code> and <code>structname</code> to override the default generated file and struct name. These options are only compatible with non-regular expressions in <code>name</code>, where only one mock is generated. <code>case</code> mockery generates files using the casing of the original interface name.  This can be modified by specifying <code>case: underscore</code> to format the generated file name using underscore casing. <code>print</code> Use <code>print: True</code> to have the resulting code printed out instead of written to disk. <code>exported</code> Use <code>exported: True</code> to generate public mocks for private interfaces. <code>with-expecter</code> Use <code>with-expecter: True</code> to generate <code>EXPECT()</code> methods for your mocks. This is the preferred way to setup your mocks. <code>testonly</code> Prepend every mock file with <code>_test.go</code>. This is useful in cases where you are generating mocks <code>inpackage</code> but don't want the mocks to be visible to code outside of tests. <code>inpackage-suffix</code> When <code>inpackage-suffix</code> is set to <code>True</code>, mock files are suffixed with <code>_mock</code> instead of being prefixed with <code>mock_</code> for InPackage mocks"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#simple-case","title":"Simple case","text":"<p>Given this interface:</p> string.go<pre><code>package example_project\n//go:generate --name Stringer\ntype Stringer interface {\nString() string\n}\n</code></pre> <p>Run: <code>go generate</code> (using the recommended config) and the the file <code>mock_Stringer_test.go</code> will be generated. You can now use this mock to create assertions and expectations.</p> string_test.go<pre><code>package example_project\nimport (\n\"testing\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc Foo(s Stringer) string {\nreturn s.String()\n}\nfunc TestString(t *testing.T) {\nmockStringer := NewMockStringer(t)\nmockStringer.EXPECT().String().Return(\"mockery\")\nassert.Equal(t, \"mockery\", Foo(mockStringer))\n}\n</code></pre> <p>Note that in combination with using the mock's constructor and the <code>.EXPECT()</code> directives, your test will automatically fail if the expected call is not made.</p>"},{"location":"examples/#function-type-case","title":"Function type case","text":"<p>Given this is in <code>send.go</code></p> Go<pre><code>package test\ntype SendFunc func(data string) (int, error)\n</code></pre> <p>Run: <code>mockery --name=SendFunc</code> and the following will be output:</p> mock_SendFunc_test.go<pre><code>package mocks\nimport (\n\"github.com/stretchr/testify/mock\"\ntesting \"testing\"\n)\ntype SendFunc struct {\nmock.Mock\n}\nfunc (_m *SendFunc) Execute(data string) (int, error) {\nret := _m.Called(data)\nvar r0 int\nif rf, ok := ret.Get(0).(func(string) int); ok {\nr0 = rf(data)\n} else {\nr0 = ret.Get(0).(int)\n}\nvar r1 error\nif rf, ok := ret.Get(1).(func(string) error); ok {\nr1 = rf(data)\n} else {\nr1 = ret.Error(1)\n}\nreturn r0, r1\n}\n// NewSendFunc creates a new instance of SendFunc. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\nfunc NewSendFunc(t testing.TB) *SendFunc {\nmock := &amp;SendFunc{}\nmock.Mock.Test(t)\nt.Cleanup(func() { mock.AssertExpectations(t) })\nreturn mock\n}\n</code></pre>"},{"location":"examples/#return-value-provider-functions","title":"Return Value Provider Functions","text":"<p>If your tests need access to the arguments to calculate the return values, set the return value to a function that takes the method's arguments as its own arguments and returns the return value. For example, given this interface:</p> Go<pre><code>package test\ntype Proxy interface {\npassthrough(ctx context.Context, s string) string\n}\n</code></pre> <p>The argument can be passed through as the return value:</p> Go<pre><code>import . \"github.com/stretchr/testify/mock\"\nproxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(func(ctx context.Context, s string) string {\nreturn s\n})\n</code></pre>"},{"location":"features/","title":"Features","text":""},{"location":"features/#expecter-structs","title":"Expecter Structs","text":"config <code>with-expecter: True</code> <p>Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the <code>with-expecter: True</code> mockery configuration, you can enter into the expecter interface by simply calling <code>.EXPECT()</code> on your mock object.</p> <p>For example, given an interface such as Go<pre><code>type Requester interface {\nGet(path string) (string, error)\n}\n</code></pre></p> <p>You can use the expecter interface as such: Go<pre><code>requesterMock := mocks.NewRequester(t)\nrequesterMock.EXPECT().Get(\"some path\").Return(\"result\", nil)\nrequesterMock.EXPECT().\nGet(mock.Anything).\nRun(func(path string) { fmt.Println(path, \"was called\") }).\n// Can still use return functions by getting the embedded mock.Call\nCall.Return(func(path string) string { return \"result for \" + path }, nil)\n</code></pre></p> <p>Note that the types of the arguments on the <code>EXPECT</code> methods are <code>interface{}</code>, not the actual type of your interface. The reason for this is that you may want to pass <code>mock.Any</code> as an argument, which means that the argument you pass may be an arbitrary type. The types are still provided in the expecter method docstrings.</p>"},{"location":"features/#return-value-providers","title":"Return Value Providers","text":"<p>Return Value Providers can be used one of two ways.  You may either define a single function with the exact same signature (number and type of input and return parameters) and pass that as a single value to <code>Return</code>, or you may pass multiple values to <code>Return</code> (one for each return parameter of the mocked function.)  If you are using the second form, for each of the return values of the mocked function, <code>Return</code> needs a function which takes the same arguments as the mocked function, and returns one of the return values. For example, if the return argument signature of <code>passthrough</code> in the above example was instead <code>(string, error)</code> in the interface, <code>Return</code> would also need a second function argument to define the error value:</p> Go<pre><code>type Proxy interface {\npassthrough(ctx context.Context, s string) (string, error)\n}\n</code></pre> <p>First form:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\nfunc(ctx context.Context, s string) (string, error) {\nreturn s, nil\n}\n)\n</code></pre> <p>Second form:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\nfunc(ctx context.Context, s string) string {\nreturn s\n},\nfunc(ctx context.Context, s string) error {\nreturn nil\n},\n)\n</code></pre>"},{"location":"installation/","title":"Getting Started","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#github-release","title":"GitHub Release","text":"<p>recommended</p> <p>Visit the releases page to download one of the pre-built binaries for your platform.</p>"},{"location":"installation/#go-install","title":"go install","text":"<p>Supported, but not recommended: see wiki page and related discussions.</p> Text Only<pre><code>go install github.com/vektra/mockery/v2@v2.20.0\n</code></pre> <p>Warning</p> <p>Do not use <code>@latest</code> as this will pull from the latest, potentially untagged, commit on master.</p>"},{"location":"installation/#docker","title":"Docker","text":"<p>Use the Docker image</p> Text Only<pre><code>docker pull vektra/mockery\n</code></pre> <p>Generate all the mocks for your project:</p> Text Only<pre><code>docker run -v \"$PWD\":/src -w /src vektra/mockery --all\n</code></pre>"},{"location":"installation/#homebrew","title":"Homebrew","text":"<p>Install through brew</p> Text Only<pre><code>brew install mockery\nbrew upgrade mockery\n</code></pre>"},{"location":"notes/","title":"Additional Notes","text":""},{"location":"notes/#variadic-arguments","title":"Variadic Arguments","text":"<p>When mocking methods with variadic arguments, some complexities are introduced. Before this PR: https://github.com/vektra/mockery/pull/123, mocking a variadic method looked like this:</p> Go<pre><code>type Foo interface {\nBar(s ...string) error\n}\nfunc TestFoo(t *testing.T) {\nm := NewMockFoo(t)\nm.On(\"Bar\", []string{\"hello\", \"world\"}).Return(nil)\n}\n</code></pre> <p>After the PR, you could use this syntax:</p> Go<pre><code>func TestFoo(t *testing.T) {\nm := NewMockFoo(t)\nm.On(\"Bar\", \"hello\", \"world\").Return(nil)\n</code></pre> <p>This introduces ambiguities because if you want to do something like this:</p> Text Only<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>This is impossible to distinguish between these two intentions: 1. Any number of variadic arguments of any value 2. A single variadic argument of any value</p> <p>This is fixed in https://github.com/vektra/mockery/pull/359 where you can provide <code>unroll-variadic: False</code> to get back to the old behavior. Thus, if you want to assert the first case, you can then do:</p> Text Only<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>If you want to specify the second case, you must set <code>unroll-variadic: True</code>. Then this assertion's intention will be modified to mean the second case:</p> Text Only<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>An upstream patch to <code>testify</code> is currently underway to allow passing <code>mock.Anything</code> directly to the variadic slice: https://github.com/stretchr/testify/pull/1348</p> <p>If this is merged, it would become possible to describe the above two cases respectively:</p> Go<pre><code>// case 1\nm.On(\"Bar\", mock.Anything).Return(nil)\n// case 2\nm.On(\"Bar\", []interface{}{mock.Anything}).Return(nil)\n</code></pre> <p>References: - https://github.com/vektra/mockery/pull/359 - https://github.com/vektra/mockery/pull/123 - https://github.com/vektra/mockery/pull/550 - https://github.com/vektra/mockery/issues/541</p>"},{"location":"notes/#semantic-versioning","title":"Semantic Versioning","text":"<p>The versioning in this project applies only to the behavior of the mockery binary itself. This project explicitly does not promise a stable internal API, but rather a stable executable. The versioning applies to the following:</p> <ol> <li>CLI arguments.</li> <li>Parsing of Golang code. New features in the Golang language will be supported in a backwards-compatible manner, except during major version bumps.</li> <li>Behavior of mock objects. Mock objects can be considered to be part of the public API.</li> <li>Behavior of mockery given a set of arguments.</li> </ol> <p>What the version does not track: 1. The interfaces, objects, methods etc. in the vektra/mockery package. 2. Compatibility of <code>go get</code>-ing mockery with new or old versions of Golang.</p>"},{"location":"notes/#mocking-interfaces-in-main","title":"Mocking interfaces in <code>main</code>","text":"<p>When your interfaces are in the main package, you should supply the <code>--inpackage</code> flag. This will generate mocks in the same package as the target code, avoiding import issues.</p>"},{"location":"running/","title":"Running","text":""},{"location":"running/#using-go-generate-recommended","title":"Using <code>go generate</code> recommended","text":"<p><code>go generate</code> is often preferred as it give you more targeted generation of specific interfaces. Use <code>generate</code> as a directive above the interface you want to generate a mock for.</p> Go<pre><code>package example_project\n//go:generate mockery --name Root\ntype Root interface {\nFoobar(s string) error\n}\n</code></pre> <p>Then simply:</p> Bash<pre><code>$ go generate      09 Feb 23 22:55 CST INF Starting mockery dry-run=false version=v2.18.0\n09 Feb 23 22:55 CST INF Using config: /Users/landonclipp/git/LandonTClipp/mockery/.mockery.yaml dry-run=false version=v2.18.0\n09 Feb 23 22:55 CST INF Walking dry-run=false version=v2.18.0\n09 Feb 23 22:55 CST INF Generating mock dry-run=false interface=Root qualified-name=github.com/vektra/mockery/v2/pkg/fixtures/example_project version=v2.18.0\n</code></pre>"},{"location":"running/#for-all-interfaces-in-project","title":"For all interfaces in project","text":"<p>If you provide <code>all: True</code>, you can generate mocks for the entire project. This is not recommended for larger projects as it can take a large amount of time parsing packages to generate mocks that you might never use.</p> Bash<pre><code>$ mockery\n09 Feb 23 22:47 CST INF Starting mockery dry-run=false version=v2.18.0\n09 Feb 23 22:47 CST INF Using config: /Users/landonclipp/git/LandonTClipp/mockery/.mockery.yaml dry-run=false version=v2.18.0\n09 Feb 23 22:47 CST INF Walking dry-run=false version=v2.18.0\n09 Feb 23 22:47 CST INF Generating mock dry-run=false interface=A qualified-name=github.com/vektra/mockery/v2/pkg/fixtures version=v2.18.0\n</code></pre> <p>Note<p>Note that in some cases, using <code>//go:generate</code> may turn out to be slower than running for entire packages. <code>go:generate</code> calls mockery once for each <code>generate</code> directive, which means that mockery may need to parse the package multiple times, which is wasteful. Good judgement is recommended when determining the best option for your own project.</p> </p> <p>Note<p>For mockery to correctly generate mocks, the command has to be run on a module (i.e. your project has to have a go.mod file)</p> </p>"}]}